import {DummyModuleInfo, FunctionInfo, ModuleInfo, PackageInfo} from "../analysis/infos";
import {gt, gte, lt, satisfies} from "semver";
import {getVulnerabilityId, Vulnerability} from "../typings/vulnerabilities";
import {Node} from "@babel/types";
import {
    addAll,
    Location,
    locationToStringWithFile,
    locationToStringWithFileAndEnd,
    mapGetArray,
    mapGetSet,
    mapGetSetPair
} from "../misc/util";
import logger, {writeStdOutIfActive} from "../misc/logger";
import {DetectionPattern} from "./patterns";
import {AccessPathPatternCanonicalizer, parseDetectionPattern} from "./patternparser";
import {FragmentState} from "../analysis/fragmentstate";
import {TypeScriptTypeInferrer} from "../typescript/typeinferrer";
import AnalysisDiagnostics from "../analysis/diagnostics";
import {ModuleFilter, PatternMatcher} from "./patternmatcher";
import Timer, {TimeoutException} from "../misc/timer";
import Solver from "../analysis/solver";
import {VulnerabilityDiagnostics} from "./diagnostics";

/**
 * If a -> vs is in the map, package a (directly or transitively) depends on packages with vulnerabilities vs.
 */
export type PackageDependencyVulnerabilities = Map<PackageInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, module a (directly or transitively) depends on modules with vulnerabilities vs.
 */
export type ModuleDependencyVulnerabilities = Map<ModuleInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, function/module a reaches functions with vulnerabilities vs.
 */
export type FunctionReachabilityVulnerabilities = Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, call site a reaches functions with vulnerabilities vs.
 */
export type CallReachabilityVulnerabilities = Map<Node, Set<Vulnerability>>;

/**
 * If a -> [vs, b] is in the map, node a in function b matches a pattern for a vulnerability in vs.
 */
export type PatternMatchVulnerabilities = Map<Node, [Set<Vulnerability>, FunctionInfo | ModuleInfo]>;

export type VulnerabilityResults = {
    package?: PackageDependencyVulnerabilities,
    module?: ModuleDependencyVulnerabilities,
    function?: FunctionReachabilityVulnerabilities,
    call?: CallReachabilityVulnerabilities,
    matches?: PatternMatchVulnerabilities
};

/**
 * Information about vulnerabilities in analyzed code.
 */
export class VulnerabilityDetector {

    /**
     * Collection of vulnerabilities, grouped by package name.
     */
    private vulnerabilities: Map<string, Array<Vulnerability>> = new Map();

    private patterns: Map<Vulnerability, Array<DetectionPattern>> = new Map();

    /**
     * Map from packages to known vulnerabilities they contain.
     */
    private vulnerabilityPackageMatches = new Map<PackageInfo, Set<Vulnerability>>();

    /**
     * Map from modules to known vulnerabilities they contain.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    private vulnerabilityModuleMatches = new Map<ModuleInfo, Set<Vulnerability>>();

    /**
     * Map from functions to known vulnerabilities they contain.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    private vulnerabilityFunctionMatches = new Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>();

    readonly diagnostics = new VulnerabilityDiagnostics;

    constructor(vs: Array<Vulnerability>) {
        const c = new AccessPathPatternCanonicalizer();
        for (const v of vs) {
            if ("osv" in v) {
                if (v.osv.affected)
                    for (const affected of v.osv.affected)
                        if (affected.package)
                            mapGetArray(this.vulnerabilities, affected.package.name).push(v);
            } else if ("npm" in v)
                mapGetArray(this.vulnerabilities, v.npm.name).push(v);
            if ("patterns" in v)
                for (const p of v.patterns) {
                    try {
                        mapGetArray(this.patterns, v).push(parseDetectionPattern(p, c));
                    } catch (dpos) {
                        logger.error(`Error: Pattern parse error:\n${p} (${getVulnerabilityId(v)})`);
                        logger.error(`${" ".repeat(dpos as number)}^ (column ${dpos})`);
                    }
                }
        }
    }

    getPatterns(): Array<DetectionPattern> {
        const res = [];
        for (const ps of this.patterns.values())
            for (const p of ps)
                res.push(p);
        return res;
    }

    /**
     * Collects vulnerabilities for the given package.
     */
    reachedPackage(packageInfo: PackageInfo) {
        const vs = this.vulnerabilities.get(packageInfo.name);
        if (vs)
            for (const v of vs)
                if (this.checkPackageMatchesVulnerability(packageInfo, v)) {
                    mapGetSet(this.vulnerabilityPackageMatches, packageInfo).add(v);
                    logger.info(`Detected vulnerable package ${packageInfo} (vulnerability: ${getVulnerabilityId(v)})`);
                }
    }

    /**
     * Collects vulnerabilities for the given module.
     * If no filename is available in a vulnerability descriptor, all modules of the vulnerable package are included.
     * If filename but no location range is available, the module top-level function is included.
     * Note: This ignores patterns in the vulnerability descriptors.
     */
    reachedModule(moduleInfo: ModuleInfo) {
        const vs = this.vulnerabilityPackageMatches.get(moduleInfo.packageInfo);
        if (vs)
            for (const v of vs)
                if (!("loc" in v) || v.loc.filename === moduleInfo.relativePath) {
                    mapGetSet(this.vulnerabilityModuleMatches, moduleInfo).add(v);
                    logger.info(`Detected vulnerable module ${moduleInfo} (vulnerability: ${getVulnerabilityId(v)})`);
                    if ("loc" in v && !("start" in v.loc))
                        mapGetSet(this.vulnerabilityFunctionMatches, moduleInfo).add(v);
                }
    }

    /**
     * Collects vulnerabilities for the given function.
     * Note: This ignores patterns in the vulnerability descriptors.
     */
    reachedFunction(fun: FunctionInfo) {
        const vs = this.vulnerabilityModuleMatches.get(fun.moduleInfo);
        if (vs)
            for (const v of vs)
                if ("loc" in v && "start" in v.loc &&
                    v.loc.start.line == fun.loc.start.line &&
                    v.loc.start.column == fun.loc.start.column &&
                    v.loc.end.line == fun.loc.end.line &&
                    v.loc.end.column == fun.loc.end.column
                ) {
                    mapGetSet(this.vulnerabilityFunctionMatches, fun).add(v);
                    logger.info(`Detected vulnerable function ${fun} (vulnerability: ${getVulnerabilityId(v)})`);
                }
    }

    /**
     * Finds the packages that may (directly or transitively) depend on a vulnerable package.
     * Dependents of entry packages are ignored.
     */
    findPackagesThatMayDependOnVulnerablePackages(matches: Map<PackageInfo, Set<Vulnerability>>, f: FragmentState): PackageDependencyVulnerabilities {
        const reverseDependencies = new Map<PackageInfo, Set<PackageInfo>>();
        for (const p of f.a.packageInfos.values())
            for (const d of p.directDependencies)
                if (!d.isEntry)
                    mapGetSet(reverseDependencies, d).add(p);
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the modules that may (directly or transitively) depend on a vulnerable module.
     * Dependents of entry packages are ignored.
     */
    findModulesThatMayDependOnVulnerableModules(matches: Map<ModuleInfo, Set<Vulnerability>>, f: FragmentState): ModuleDependencyVulnerabilities {
        const reverseDependencies = new Map<ModuleInfo, Set<ModuleInfo>>();
        for (const p of f.a.packageInfos.values())
            if (!p.isEntry)
                for (const m of p.modules.values())
                    addAll(m.directDependents, mapGetSet(reverseDependencies, m));
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the functions that may reach a vulnerable function (including module top-level functions).
     * Call edges to entry packages are ignored.
     */
    findFunctionsThatMayReachVulnerableFunctions(matches: Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>, f: FragmentState): FunctionReachabilityVulnerabilities {
        const reverseDependencies = new Map<FunctionInfo | ModuleInfo, Set<FunctionInfo | ModuleInfo>>();
        function add(d: FunctionInfo | ModuleInfo, n: FunctionInfo | ModuleInfo) {
            if (!d.packageInfo.isEntry)
                mapGetSet(reverseDependencies, d).add(n);
        }
        function visitFunction(n: FunctionInfo) {
            for (const q of n.functions)
                visitFunction(q);
            const r = f.functionToFunction.get(n);
            if (r)
                for (const d of r)
                    add(d, n);
            const r2 = f.requireGraph.get(n);
            if (r2)
                for (const d of r2)
                    add(d, n);
        }
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        add(d, m);
                const t = f.functionToFunction.get(m);
                if (t)
                    for (const d of t)
                        add(d, m);
                for (const n of m.functions)
                    visitFunction(n);
            }
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the call sites that may reach a vulnerable function.
     * Call edges to entry packages are ignored.
     */
    findCallsThatMayReachVulnerableFunctions(f: FragmentState, fvs: FunctionReachabilityVulnerabilities): CallReachabilityVulnerabilities {
        const res = new Map<Node, Set<Vulnerability>>();
        for (const [call, s] of f.callToFunctionOrModule)
            for (const n of s)
                if (n instanceof FunctionInfo || n instanceof ModuleInfo)
                    if (!n.packageInfo.isEntry) {
                        const vs = fvs.get(n);
                        if (vs)
                            addAll(vs, mapGetSet(res, call));
                    }
        return res;
    }

    private propagateBackwards<T>(matches: Map<T, Set<Vulnerability>>, reverseDependencies: Map<T, Set<T>>): Map<T, Set<Vulnerability>> {
        // initialize work-list
        const w = new Map<T, Set<Vulnerability>>();
        for (const [p, vs] of matches)
            w.set(p, new Set(vs));
        // propagate backwards
        const res = new Map<T, Set<Vulnerability>>();
        for (const [p, vs] of w) {
            w.delete(p);
            addAll(vs, mapGetSet(res, p));
            const r = reverseDependencies.get(p);
            if (r)
                for (const d of r)
                    for (const v of vs)
                        if (!mapGetSet(res, d).has(v))
                            mapGetSet(w, d).add(v);
        }
        return res;
    }

    /**
     * Reports the vulnerability reachability results.
     */
    reportResults(f: FragmentState, vulnerabilities: VulnerabilityResults) {
        // TODO: vulnerabilities.matches reported immediately by patternMatch, move here?
        let cp = 0, cm = 0, cf = 0, cc = 0;
        if (vulnerabilities.package)
            for (const [src, vs] of vulnerabilities.package)
                if (src.isEntry)
                    for (const v of vs) {
                        logger.info(`Vulnerability warning: Entry package ${src} depends on package with vulnerability ${getVulnerabilityId(v)}`);
                        cp++;
                    }
        if (vulnerabilities.module)
            for (const [src, vs] of vulnerabilities.module)
                if (src.packageInfo.isEntry)
                    for (const v of vs) {
                        logger.info(`Vulnerability warning: Entry package module ${src} depends on module with vulnerability ${getVulnerabilityId(v)}`);
                        cm++;
                    }
        if (vulnerabilities.function)
            for (const [src, vs] of vulnerabilities.function)
                if (src.packageInfo.isEntry)
                    for (const v of vs) {
                        logger.info(`Vulnerability warning: Entry package function ${src} may reach function with vulnerability ${getVulnerabilityId(v)}`);
                        cf++;
                    }
        if (vulnerabilities.call)
            for (const [src, vs] of vulnerabilities.call)
                if ((src.loc as Location)?.module?.packageInfo.isEntry)
                    for (const v of vs) {
                        logger.info(`Vulnerability warning: Entry package function call site ${locationToStringWithFile(src.loc)} may reach function with vulnerability ${getVulnerabilityId(v)}`);
                        cc++;
                    }
        logger.info(`Vulnerability summary:\n` +
            `  Entry packages that depend on package with vulnerability: ${cp}\n` +
            `  Entry package modules that depend on module with vulnerability: ${cm}\n` +
            `  Entry package functions that may reach function with vulnerability: ${cf}\n` +
            `  Entry package function call site that may reach function vulnerability: ${cc}`);
        if (logger.isDebugEnabled()) {
            if (vulnerabilities.package)
                for (const [src, vs] of vulnerabilities.package)
                    if (!src.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package ${src} depends on package with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.module)
                for (const [src, vs] of vulnerabilities.module)
                    if (!src.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package module ${src} depends on module with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.function)
                for (const [src, vs] of vulnerabilities.function)
                    if (!src.packageInfo.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package function ${src} may reach function with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.call)
                for (const [src, vs] of vulnerabilities.call)
                    if (!(src.loc as Location)?.module?.packageInfo.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package function call site ${locationToStringWithFile(src.loc)} may reach function with vulnerability ${getVulnerabilityId(v)}`);
        }
        // TODO: also optionally store vr.matches, vr.package, vs.module, vs.function, vs.call?
        // TODO: also report paths using SARIF format?
    }

    /**
     * Checks whether a package matches a vulnerability descriptor.
     * Based on https://ossf.github.io/osv-schema/#evaluation.
     */
    private checkPackageMatchesVulnerability(p: PackageInfo, v: Vulnerability): boolean {
        if ("osv" in v) {
            if (v.osv.affected)
                for (const affected of v.osv.affected)
                    if (affected.package && affected.package.name === p.name) {
                        if (p.version === undefined)
                            return true;
                        if (affected.versions)
                            for (const version of affected.versions)
                                if (version === p.version)
                                    return true;
                        if (affected.ranges) {
                            for (const range of affected.ranges) {
                                let beforeLimits = false;
                                if (!range.events.some(event => "limit" in event))
                                    beforeLimits = true;
                                else
                                    for (const event of range.events)
                                        if (event.limit && (event.limit === "*" || lt(p.version, event.limit))) {
                                            beforeLimits = true;
                                            break;
                                        }
                                if (beforeLimits) {
                                    let match = false;
                                    for (const event of range.events) { // TODO: assuming already sorted - OK?
                                        if (event.introduced && (event.introduced === "0" || gte(p.version, event.introduced)))
                                            match = true;
                                        else if (event.fixed && gte(p.version, event.fixed))
                                            match = false;
                                        else if (event.last_affected && gt(p.version, event.last_affected))
                                            match = false;
                                    }
                                    if (match)
                                        return true;
                                }
                            }
                        }
                    }
        } else if ("npm" in v) {
            if (v.npm.name === p.name) {
                if (p.version === undefined)
                    return true;
                return satisfies(p.version, v.npm.range);
            }
        }
        return false;
    }

    /**
     * Performs pattern matching on the given analysis state.
     */
    patternMatch(fragmentState: FragmentState, typer: TypeScriptTypeInferrer | undefined, diagnostics: AnalysisDiagnostics): PatternMatchVulnerabilities {
        const res = new Map<Node, [Set<Vulnerability>, FunctionInfo | ModuleInfo]>();
        writeStdOutIfActive("Pattern matching...");
        try {
            const matcher = new PatternMatcher(fragmentState, typer);
            for (const [v, ps] of this.patterns)
                for (const p of ps) {
                    const moduleFilter: ModuleFilter = (m) => m instanceof DummyModuleInfo || this.checkPackageMatchesVulnerability(m.packageInfo, v);
                    for (const m of matcher.findDetectionPatternMatches(p, diagnostics, moduleFilter)) { // TODO: special mode for findDetectionPatternMatches to ignore certainty information?
                        logger.info(`Vulnerability pattern match: ${p} at ${locationToStringWithFileAndEnd(m.exp.loc)} (vulnerability: ${getVulnerabilityId(v)})`);
                        mapGetSetPair(res, m.exp, m.encl).add(v);
                    }
                }
        } catch (ex) {
            if (ex instanceof TimeoutException) {
                logger.error("Time limit reached, pattern matching aborted");
                diagnostics.timeout = true;
            } else
                throw ex;
        }
        return res;
    }

    /**
     * Collects all vulnerability results and updates diagnostics.
     */
    collectAllVulnerabilityResults(solver: Solver, typer: TypeScriptTypeInferrer | undefined): VulnerabilityResults {
        const f = solver.fragmentState;
        const vr: VulnerabilityResults = {};
        const t = new Timer();
        vr.matches = this.patternMatch(f, typer, solver.diagnostics);
        const pcks = new Map(this.vulnerabilityPackageMatches);
        const mods = new Map(this.vulnerabilityModuleMatches);
        const funs = new Map(this.vulnerabilityFunctionMatches);
        for (const [vs, fun] of vr.matches.values()) { // add pattern matches to location matches for functions, modules, and packages
            const mod = fun instanceof FunctionInfo ? fun.moduleInfo : fun;
            addAll(vs, mapGetSet(funs, fun));
            addAll(vs, mapGetSet(mods, mod));
            addAll(vs, mapGetSet(pcks, mod.packageInfo));
        }
        vr.package = this.findPackagesThatMayDependOnVulnerablePackages(pcks, f);
        vr.module = this.findModulesThatMayDependOnVulnerableModules(mods, f);
        vr.function = this.findFunctionsThatMayReachVulnerableFunctions(funs, f);
        vr.call = this.findCallsThatMayReachVulnerableFunctions(f, vr.function);
        for (const [c, [vs]] of vr.matches) // add pattern matches to location matches for calls
            addAll(vs, mapGetSet(vr.call, c));
        const d = this.diagnostics;
        d.vulnerabilityCollectionTime = t.elapsed(); // TODO: need abort timeout?
        d.distinctVulnerabilities =
            pcks.values().reduce((p, c) => (addAll(c, p), p), new Set).size;
        d.packagesWithVulnerabilityLocationMatches = this.vulnerabilityPackageMatches.size;
        d.modulesWithVulnerabilityLocationMatches = this.vulnerabilityModuleMatches.size;
        d.functionsWithVulnerabilityLocationMatches = this.vulnerabilityFunctionMatches.size;
        d.nodesWithVulnerabilityPatternMatches = vr.matches.size;
        d.packagesThatMayDependOnVulnerablePackages = vr.package.size;
        d.modulesThatMayDependOnVulnerableModules = vr.module.size;
        d.functionsThatMayReachVulnerableFunctions = vr.function.size;
        d.callsThatMayReachVulnerableFunctions = vr.call.size;
        d.entryPackagesWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityPackageMatches.keys().filter(f => f.isEntry)).length;
        d.entryPackageModulesWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityModuleMatches.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageFunctionsWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityFunctionMatches.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageNodesWithVulnerabilityPatternMatches =
            Array.from(vr.matches.entries().filter(([, [, f]]) => f.packageInfo.isEntry)).length;
        d.entryPackagesThatMayDependOnVulnerablePackages =
            Array.from(vr.package.keys().filter(f => f.isEntry)).length;
        d.entryPackageModulesThatMayDependOnVulnerableModules =
            Array.from(vr.module.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageFunctionsThatMayReachVulnerableFunctions =
            Array.from(vr.function.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageCallsThatMayReachVulnerableFunctions =
            Array.from(vr.call.keys().filter(f => (f.loc as Location)?.module?.packageInfo.isEntry)).length;
        return vr;
    }
}
