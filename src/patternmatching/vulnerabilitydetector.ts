import {FunctionInfo, ModuleInfo, PackageInfo} from "../analysis/infos";
import {OpenSourceVulnerability} from "../typings/osv";
import {gt, gte, lt} from "semver";
import {Vulnerability} from "../typings/vulnerabilities";
import {NodePath} from "@babel/traverse";
import {Class, Function, Node} from "@babel/types";
import {
    addAll,
    mapGetArray,
    mapGetMap,
    mapGetSet,
    sourceLocationToStringWithFile,
    sourceLocationToStringWithFileAndEnd
} from "../misc/util";
import logger, {writeStdOutIfActive} from "../misc/logger";
import {DetectionPattern} from "./patterns";
import {AccessPathPatternCanonicalizer, parseDetectionPattern} from "./patternparser";
import {FragmentState} from "../analysis/fragmentstate";
import {TypeScriptTypeInferrer} from "../typescript/typeinferrer";
import {AnalysisDiagnostics} from "../typings/diagnostics";
import {PatternMatcher} from "./patternmatcher";
import {TimeoutException} from "../misc/timer";

/**
 * If a -> b -> vs is in the map, package a depends on package b which has vulnerabilities vs.
 */
export type PackageDependencyVulnerabilities = Map<PackageInfo, Map<PackageInfo, Set<Vulnerability>>>;

/**
 * If a -> b -> vs is in the map, module a depends on module b which has vulnerabilities vs.
 */
export type ModuleDependencyVulnerabilities = Map<ModuleInfo, Map<ModuleInfo, Set<Vulnerability>>>;

/**
 * If a -> b -> vs is in the map, function/module a reaches function/module b which has vulnerabilities vs.
 */
export type FunctionReachabilityVulnerabilities = Map<FunctionInfo | ModuleInfo, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;

/**
 * If a -> b -> vs is in the map, call site a reaches function/module b which has vulnerabilities vs.
 */
export type CallReachabilityVulnerabilities = Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;

/**
 * If a -> b -> vs is in the map, call site a in function b matches a pattern for a vulnerability in vs.
 */
export type PatternMatchVulnerabilities = Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;

export type VulnerabilityResults = {
    package?: PackageDependencyVulnerabilities,
    module?: ModuleDependencyVulnerabilities,
    function?: FunctionReachabilityVulnerabilities,
    call?: CallReachabilityVulnerabilities,
    matches?: PatternMatchVulnerabilities
}

/**
 * Information about vulnerabilities in analyzed code.
 */
export class VulnerabilityDetector {

    /**
     * Collection of vulnerabilities, grouped by package name.
     */
    private vulnerabilities: Map<string, Array<Vulnerability>> = new Map();

    private patterns: Map<Vulnerability, Array<DetectionPattern>> = new Map();

    /**
     * Map from packages to known vulnerabilities they contain.
     */
    vulnerabilityPackageMatches = new Map<PackageInfo, Set<Vulnerability>>();

    /**
     * Map from modules to known vulnerabilities they contain.
     */
    vulnerabilityModuleMatches = new Map<ModuleInfo, Set<Vulnerability>>();

    /**
     * Map from functions to known vulnerabilities they contain.
     */
    vulnerabilityFunctionMatches = new Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>();

    constructor(vs: Array<Vulnerability>) {
        const c = new AccessPathPatternCanonicalizer()
        for (const v of vs) {
            if (v.osv.affected)
                for (const affected of v.osv.affected)
                    if (affected.package && affected.package.ecosystem === "npm")
                        mapGetArray(this.vulnerabilities, affected.package.name).push(v);
            if (v.patterns)
                for (const p of v.patterns) {
                    const dp = `call ${p}`;
                    try {
                        mapGetArray(this.patterns, v).push(parseDetectionPattern(dp, c));
                    } catch (dpos) {
                        const pos = dpos as number - 5;
                        logger.error(`Error: Pattern parse error:\n${p} (${v.osv.id})`);
                        logger.error(`${" ".repeat(pos as number)}^ (column ${pos})`);
                    }
                }
        }
    }

    getPatterns(): Array<DetectionPattern> {
        const res = [];
        for (const ps of this.patterns.values())
            for (const p of ps)
                res.push(p);
        return res;
    }

    /**
     * Collects vulnerabilities for the given package.
     */
    reachedPackage(packageInfo: PackageInfo) {
        const vs = this.vulnerabilities.get(packageInfo.name);
        if (vs) {
            for (const v of vs)
                if (this.checkPackageMatchesOpenSourceVulnerability(packageInfo, v.osv)) {
                    mapGetSet(this.vulnerabilityPackageMatches, packageInfo).add(v);
                    logger.info(`Detected vulnerable package ${packageInfo} (vulnerability: ${v.osv.id})`);
                }
        }
    }

    /**
     * Collects vulnerabilities for the given module.
     */
    reachedModule(moduleInfo: ModuleInfo) {
        const vs = this.vulnerabilityPackageMatches.get(moduleInfo.packageInfo);
        if (vs) {
            for (const v of vs)
                if (this.checkModuleContainsVulnerabilityLocation(moduleInfo, v.location)) {
                    mapGetSet(this.vulnerabilityModuleMatches, moduleInfo).add(v);
                    logger.info(`Detected vulnerable module ${moduleInfo} (vulnerability: ${v.osv.id})`);
                    if (v.location && !v.location.line && !v.location.code) // if no line or code is given, we assume the whole module is vulnerable
                        mapGetSet(this.vulnerabilityFunctionMatches, moduleInfo).add(v);
                }
        }
    }

    /**
     * Collects vulnerabilities for the given function.
     */
    reachedFunction(fun: NodePath<Function | Class>, functionInfo: FunctionInfo) {
        const vs = this.vulnerabilityModuleMatches.get(functionInfo.moduleInfo);
        if (vs) {
            for (const v of vs)
                if (this.checkFunctionContainsVulnerabilityLocation(fun, v.location)) {
                    mapGetSet(this.vulnerabilityFunctionMatches, functionInfo).add(v);
                    logger.info(`Detected vulnerable function ${functionInfo} (vulnerability: ${v.osv.id})`);
                }
        }
    }

    /**
     * Finds the packages that may depend on a vulnerable package.
     */
    findPackagesThatMayDependOnVulnerablePackages(f: FragmentState): PackageDependencyVulnerabilities {
        const reverseDependencies = new Map<PackageInfo, Set<PackageInfo>>();
        for (const p of f.a.packageInfos.values())
            for (const d of p.directDependencies)
                mapGetSet(reverseDependencies, d).add(p);
        return this.propagateBackwards(this.vulnerabilityPackageMatches, reverseDependencies);
    }

    /**
     * Finds the modules that may depend on a vulnerable module.
     */
    findModulesThatMayDependOnVulnerableModules(f: FragmentState): ModuleDependencyVulnerabilities {
        const reverseDependencies = new Map<ModuleInfo, Set<ModuleInfo>>();
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        mapGetSet(reverseDependencies, d).add(m);
            }
        return this.propagateBackwards(this.vulnerabilityModuleMatches, reverseDependencies);
    }

    /**
     * Finds the functions that may reach a vulnerable function (including module top-level functions).
     */
    findFunctionsThatMayReachVulnerableFunctions(f: FragmentState): FunctionReachabilityVulnerabilities {
        const reverseDependencies = new Map<FunctionInfo | ModuleInfo, Set<FunctionInfo | ModuleInfo>>();
        function add(d: FunctionInfo | ModuleInfo, n: FunctionInfo | ModuleInfo) {
            if (!d.packageInfo.isEntry || !n.packageInfo.isEntry) // stop when reaching entry package
                mapGetSet(reverseDependencies, d).add(n);
        }
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        add(d, m);
                for (const n of m.functions.values()) {
                    const r = f.functionToFunction.get(n);
                    if (r)
                        for (const d of r)
                            add(d, n);
                }
                const t = f.functionToFunction.get(m);
                if (t)
                    for (const d of t)
                        add(d, m);
            }
        return this.propagateBackwards(this.vulnerabilityFunctionMatches, reverseDependencies);
    }

    /**
     * Finds the call sites that may reach a vulnerable function (including module top-level functions) in a non-entry package.
     */
    findCallsThatMayReachVulnerableFunctions(f: FragmentState, fvs: FunctionReachabilityVulnerabilities): CallReachabilityVulnerabilities {
        const res = new Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>();
        for (const [call, s] of f.callToFunctionOrModule)
            for (const n of s)
                if (n instanceof FunctionInfo || n instanceof ModuleInfo)
                    if (!n.packageInfo.isEntry) { // exclude call edges to entry package
                        const m = fvs.get(n);
                        if (m)
                            for (const [dst, vs] of m)
                                addAll(vs, mapGetSet(mapGetMap(res, call), dst));
                    }
        return res;
    }

    private propagateBackwards<T>(matches: Map<T, Set<Vulnerability>>, reverseDependencies: Map<T, Set<T>>): Map<T, Map<T, Set<Vulnerability>>> {
        // initialize work-list
        const w = new Map<T, Map<T, Set<Vulnerability>>>();
        for (const [p, vs] of matches)
            w.set(p, new Map([[p, new Set(vs)]]));
        // propagate backwards
        const res = new Map<T, Map<T, Set<Vulnerability>>>();
        for (const [p, m] of w) {
            w.delete(p);
            for (const [q, vs] of m) {
                addAll(vs, mapGetSet(mapGetMap(res, p), q));
                const r = reverseDependencies.get(p);
                if (r)
                    for (const d of r)
                        for (const v of vs) {
                            const m = mapGetMap(res, d);
                            const t = mapGetMap(w, d);
                            if (!mapGetSet(m, q).has(v))
                                mapGetSet(t, q).add(v);
                        }
            }
        }
        return res;
    }

    /**
     * Reports the vulnerability reachability results.
     */
    reportResults(f: FragmentState, vulnerabilities: VulnerabilityResults) {
        if (vulnerabilities.package)
            for (const [src, m] of vulnerabilities.package)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.isEntry)
                                logger.warn(`Vulnerability warning: Main package ${src} depends on vulnerable package ${dst} (vulnerability: ${v.osv.id})`);
                            else
                                logger.warn(`Vulnerability warning: Dependency package ${src} depends on vulnerable package ${dst} (vulnerability: ${v.osv.id})`);
        if (vulnerabilities.module)
            for (const [src, m] of vulnerabilities.module)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.isEntry)
                                logger.warn(`Vulnerability warning: Main module ${src} depends on vulnerable module ${dst} (vulnerability: ${v.osv.id})`);
                            else
                                logger.warn(`Vulnerability warning: Dependency module ${src} depends on vulnerable module ${dst} (vulnerability: ${v.osv.id})`);
        if (vulnerabilities.function)
            for (const [src, m] of vulnerabilities.function)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.packageInfo.isEntry)
                                logger.warn(`Vulnerability warning: Main package ${src instanceof FunctionInfo ? "function" : "module"} ${src} may reach vulnerable function ${dst} (vulnerability: ${v.osv.id})`);
                            else
                                logger.warn(`Vulnerability warning: Dependency ${src instanceof FunctionInfo ? "function" : "module"} ${src} may reach vulnerable function ${dst} (vulnerability: ${v.osv.id})`);
        if (vulnerabilities.call)
            for (const [src, m] of vulnerabilities.call)
                for (const [dst, vs] of m)
                    for (const v of vs)
                        if (f.callToContainingFunction.get(src)!.packageInfo.isEntry)
                            logger.warn(`Vulnerability warning: Main package function call site ${sourceLocationToStringWithFile(src.loc)} may reach vulnerable function ${dst} (vulnerability: ${v.osv.id})`);
                        else
                            logger.warn(`Vulnerability warning: Dependency function call site ${sourceLocationToStringWithFile(src.loc)} may reach vulnerable function ${dst} (vulnerability: ${v.osv.id})`);
        // TODO: also report paths, use SARIF format?
    }

    /**
     * Checks whether a package matches an OSV entry.
     * Based on https://ossf.github.io/osv-schema/#evaluation.
     */
    private checkPackageMatchesOpenSourceVulnerability(p: PackageInfo, osv: OpenSourceVulnerability): boolean {
        if (osv.affected)
            for (const affected of osv.affected)
                if (affected.package && affected.package.ecosystem === "npm" && affected.package.name === p.name) {
                    if (p.version === undefined)
                        return true;
                    if (affected.versions)
                        for (const version of affected.versions)
                            if (version === p.version)
                                return true;
                    if (affected.ranges) {
                        for (const range of affected.ranges) {
                            let beforeLimits = false;
                            if (!range.events.find(event => "limit" in event))
                                beforeLimits = true;
                            else
                                for (const event of range.events)
                                    if (event.limit && (event.limit === "*" || lt(p.version, event.limit))) {
                                        beforeLimits = true;
                                        break;
                                    }
                            if (beforeLimits) {
                                let match = false;
                                for (const event of range.events) { // TODO: assuming already sorted - OK?
                                    if (event.introduced && (event.introduced === "0" || gte(p.version, event.introduced)))
                                        match = true;
                                    else if (event.fixed && gte(p.version, event.fixed))
                                        match = false;
                                    else if (event.last_affected && gt(p.version, event.last_affected))
                                        match = false;
                                }
                                if (match)
                                    return true;
                            }
                        }
                    }
                }
        return false;
    }

    /**
     * Checks if the location is likely in the module.
     */
    private checkModuleContainsVulnerabilityLocation(moduleInfo: ModuleInfo, loc: Vulnerability["location"]): boolean {
        return Boolean(loc && loc.file === moduleInfo.relativePath);
    }

    /**
     * Checks if the location is likely in the function (or one of its inner functions).
     * It is assumed that the function is in the module.
     */
    private checkFunctionContainsVulnerabilityLocation(fun: NodePath<Function | Class>, loc: Vulnerability["location"]): boolean {
        if (!(loc && loc.file && loc.line && loc.code))
            return false;
        const source = fun.getSource();
        const firstMatch = source.indexOf(loc.code);
        if (firstMatch === -1)
            return false;
        const multipleMatches = source.indexOf(loc.code, firstMatch + 1) !== -1;
        if (!multipleMatches)
            return true;
        return Boolean(fun.node.loc?.start.line && fun.node.loc?.end.line && fun.node.loc?.start.line <= loc.line + 1 && loc.line <= fun.node.loc?.end.line + 1);
    }

    /**
     * Performs pattern matching on the given analysis state.
     */
    patternMatch(fragmentState: FragmentState, typer?: TypeScriptTypeInferrer, diagnostics?: AnalysisDiagnostics): PatternMatchVulnerabilities {
        const res = new Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>();
        writeStdOutIfActive("Pattern matching...");
        try {
            const matcher = new PatternMatcher(fragmentState, typer);
            for (const [v, ps] of this.patterns)
                for (const p of ps)
                    for (const m of matcher.findDetectionPatternMatches(p)) { // TODO: special mode for findDetectionPatternMatches to ignore certainty information?
                        logger.info(`Detected call to vulnerable function: ${p} at ${sourceLocationToStringWithFileAndEnd(m.exp.loc)} (vulnerability: ${v.osv.id})`);
                        mapGetSet(mapGetMap(res, m.exp), fragmentState.callToContainingFunction.get(m.exp)).add(v);
                    }
        } catch (ex) {
            if (ex instanceof TimeoutException) {
                logger.error("Time limit reached, pattern matching aborted");
                if (diagnostics)
                    diagnostics.timeout = true;
            } else
                throw ex;
        }
        return res;
    }
}