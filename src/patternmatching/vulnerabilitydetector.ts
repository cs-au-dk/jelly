import {DummyModuleInfo, FunctionInfo, ModuleInfo, PackageInfo} from "../analysis/infos";
import {gt, gte, lt, satisfies} from "semver";
import {getVulnerabilityId, Vulnerability} from "../typings/vulnerabilities";
import {NodePath} from "@babel/traverse";
import {Class, Function, Node} from "@babel/types";
import {
    addAll,
    Location,
    locationToStringWithFile,
    locationToStringWithFileAndEnd,
    mapGetArray,
    mapGetSet,
    mapGetSetPair
} from "../misc/util";
import logger, {writeStdOutIfActive} from "../misc/logger";
import {DetectionPattern} from "./patterns";
import {AccessPathPatternCanonicalizer, parseDetectionPattern} from "./patternparser";
import {FragmentState} from "../analysis/fragmentstate";
import {TypeScriptTypeInferrer} from "../typescript/typeinferrer";
import AnalysisDiagnostics from "../analysis/diagnostics";
import {ModuleFilter, PatternMatcher} from "./patternmatcher";
import Timer, {TimeoutException} from "../misc/timer";
import Solver from "../analysis/solver";
import {VulnerabilityDiagnostics} from "./diagnostics";

/**
 * If a -> vs is in the map, package a (directly or transitively) depends on packages with vulnerabilities vs.
 */
export type PackageDependencyVulnerabilities = Map<PackageInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, module a (directly or transitively) depends on modules with vulnerabilities vs.
 */
export type ModuleDependencyVulnerabilities = Map<ModuleInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, function/module a reaches functions with vulnerabilities vs.
 */
export type FunctionReachabilityVulnerabilities = Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>;

/**
 * If a -> vs is in the map, call site a reaches functions with vulnerabilities vs.
 */
export type CallReachabilityVulnerabilities = Map<Node, Set<Vulnerability>>;

/**
 * If a -> [vs, b] is in the map, node a in function b matches a pattern for a vulnerability in vs.
 */
export type PatternMatchVulnerabilities = Map<Node, [Set<Vulnerability>, FunctionInfo | ModuleInfo]>;

export type VulnerabilityResults = {
    package?: PackageDependencyVulnerabilities,
    module?: ModuleDependencyVulnerabilities,
    function?: FunctionReachabilityVulnerabilities,
    call?: CallReachabilityVulnerabilities,
    matches?: PatternMatchVulnerabilities
}

/**
 * Information about vulnerabilities in analyzed code.
 */
export class VulnerabilityDetector {

    /**
     * Collection of vulnerabilities, grouped by package name.
     */
    private vulnerabilities: Map<string, Array<Vulnerability>> = new Map();

    private patterns: Map<Vulnerability, Array<DetectionPattern>> = new Map();

    /**
     * Map from packages to known vulnerabilities they contain.
     */
    private vulnerabilityPackageMatches = new Map<PackageInfo, Set<Vulnerability>>();

    /**
     * Map from modules to known vulnerabilities they contain.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    private vulnerabilityModuleMatches = new Map<ModuleInfo, Set<Vulnerability>>();

    /**
     * Map from functions to known vulnerabilities they contain.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    private vulnerabilityFunctionMatches = new Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>();

    readonly diagnostics = new VulnerabilityDiagnostics;

    constructor(vs: Array<Vulnerability>) {
        const c = new AccessPathPatternCanonicalizer();
        for (const v of vs) {
            if ("affected" in v.osv && v.osv.affected) {
                for (const affected of v.osv.affected)
                    if (affected.package && affected.package.ecosystem === "npm")
                        mapGetArray(this.vulnerabilities, affected.package.name).push(v);
            } else if ("dependency" in v.osv)
                mapGetArray(this.vulnerabilities, v.osv.dependency).push(v);
            if (v.patterns)
                for (const p of v.patterns) {
                    try {
                        mapGetArray(this.patterns, v).push(parseDetectionPattern(p, c));
                    } catch (dpos) {
                        logger.error(`Error: Pattern parse error:\n${p} (${getVulnerabilityId(v)})`);
                        logger.error(`${" ".repeat(dpos as number)}^ (column ${dpos})`);
                    }
                }
        }
    }

    getPatterns(): Array<DetectionPattern> {
        const res = [];
        for (const ps of this.patterns.values())
            for (const p of ps)
                res.push(p);
        return res;
    }

    /**
     * Collects vulnerabilities for the given package.
     */
    reachedPackage(packageInfo: PackageInfo) {
        const vs = this.vulnerabilities.get(packageInfo.name);
        if (vs)
            for (const v of vs)
                if (this.checkPackageMatchesOpenSourceVulnerability(packageInfo, v.osv)) {
                    mapGetSet(this.vulnerabilityPackageMatches, packageInfo).add(v);
                    logger.info(`Detected vulnerable package ${packageInfo} (vulnerability: ${getVulnerabilityId(v)})`);
                }
    }

    /**
     * Collects vulnerabilities for the given module.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    reachedModule(moduleInfo: ModuleInfo) {
        const vs = this.vulnerabilityPackageMatches.get(moduleInfo.packageInfo);
        if (vs)
            for (const v of vs)
                if (this.checkModuleContainsVulnerabilityLocation(moduleInfo, v.location)) {
                    mapGetSet(this.vulnerabilityModuleMatches, moduleInfo).add(v);
                    logger.info(`Detected vulnerable module ${moduleInfo} (vulnerability: ${getVulnerabilityId(v)})`);
                    if (v.location && !v.location.line && !v.location.code) // if no line or code is given, we assume the whole module is vulnerable
                        mapGetSet(this.vulnerabilityFunctionMatches, moduleInfo).add(v);
                }
    }

    /**
     * Collects vulnerabilities for the given function.
     * Note: This considers only vulnerabilities with source locations, not with patterns.
     */
    reachedFunction(fun: NodePath<Function | Class>, functionInfo: FunctionInfo) {
        const vs = this.vulnerabilityModuleMatches.get(functionInfo.moduleInfo);
        if (vs)
            for (const v of vs)
                if (this.checkFunctionContainsVulnerabilityLocation(fun, v.location)) {
                    mapGetSet(this.vulnerabilityFunctionMatches, functionInfo).add(v);
                    logger.info(`Detected vulnerable function ${functionInfo} (vulnerability: ${getVulnerabilityId(v)})`);
                }
    }

    /**
     * Finds the packages that may (directly or transitively) depend on a vulnerable package.
     * Dependents of entry packages are ignored.
     */
    findPackagesThatMayDependOnVulnerablePackages(matches: Map<PackageInfo, Set<Vulnerability>>, f: FragmentState): PackageDependencyVulnerabilities {
        const reverseDependencies = new Map<PackageInfo, Set<PackageInfo>>();
        for (const p of f.a.packageInfos.values())
            for (const d of p.directDependencies)
                if (!d.isEntry)
                    mapGetSet(reverseDependencies, d).add(p);
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the modules that may (directly or transitively) depend on a vulnerable module.
     * Dependents of entry packages are ignored.
     */
    findModulesThatMayDependOnVulnerableModules(matches: Map<ModuleInfo, Set<Vulnerability>>, f: FragmentState): ModuleDependencyVulnerabilities {
        const reverseDependencies = new Map<ModuleInfo, Set<ModuleInfo>>();
        for (const p of f.a.packageInfos.values())
            if (!p.isEntry)
                for (const m of p.modules.values())
                    addAll(m.directDependents, mapGetSet(reverseDependencies, m));
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the functions that may reach a vulnerable function (including module top-level functions).
     * Call edges to entry packages are ignored.
     */
    findFunctionsThatMayReachVulnerableFunctions(matches: Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>, f: FragmentState): FunctionReachabilityVulnerabilities {
        const reverseDependencies = new Map<FunctionInfo | ModuleInfo, Set<FunctionInfo | ModuleInfo>>();
        function add(d: FunctionInfo | ModuleInfo, n: FunctionInfo | ModuleInfo) {
            if (!d.packageInfo.isEntry)
                mapGetSet(reverseDependencies, d).add(n);
        }
        function visitFunction(n: FunctionInfo) {
            for (const q of n.functions)
                visitFunction(q);
            const r = f.functionToFunction.get(n);
            if (r)
                for (const d of r)
                    add(d, n);
            const r2 = f.requireGraph.get(n);
            if (r2)
                for (const d of r2)
                    add(d, n);
        }
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        add(d, m);
                const t = f.functionToFunction.get(m);
                if (t)
                    for (const d of t)
                        add(d, m);
                for (const n of m.functions)
                    visitFunction(n);
            }
        return this.propagateBackwards(matches, reverseDependencies);
    }

    /**
     * Finds the call sites that may reach a vulnerable function.
     * Call edges to entry packages are ignored.
     */
    findCallsThatMayReachVulnerableFunctions(f: FragmentState, fvs: FunctionReachabilityVulnerabilities): CallReachabilityVulnerabilities {
        const res = new Map<Node, Set<Vulnerability>>();
        for (const [call, s] of f.callToFunctionOrModule)
            for (const n of s)
                if (n instanceof FunctionInfo || n instanceof ModuleInfo)
                    if (!n.packageInfo.isEntry) {
                        const vs = fvs.get(n);
                        if (vs)
                            addAll(vs, mapGetSet(res, call));
                    }
        return res;
    }

    private propagateBackwards<T>(matches: Map<T, Set<Vulnerability>>, reverseDependencies: Map<T, Set<T>>): Map<T, Set<Vulnerability>> {
        // initialize work-list
        const w = new Map<T, Set<Vulnerability>>();
        for (const [p, vs] of matches)
            w.set(p, new Set(vs));
        // propagate backwards
        const res = new Map<T, Set<Vulnerability>>();
        for (const [p, vs] of w) {
            w.delete(p);
            addAll(vs, mapGetSet(res, p));
            const r = reverseDependencies.get(p);
            if (r)
                for (const d of r)
                    for (const v of vs)
                        if (!mapGetSet(res, d).has(v))
                            mapGetSet(w, d).add(v);
        }
        return res;
    }

    /**
     * Reports the vulnerability reachability results.
     */
    reportResults(f: FragmentState, vulnerabilities: VulnerabilityResults) {
        // TODO: vulnerabilities.matches reported immediately by patternMatch, move here?
        if (vulnerabilities.package)
            for (const [src, vs] of vulnerabilities.package)
                if (src.isEntry)
                    for (const v of vs)
                        logger.info(`Vulnerability warning: Entry package ${src} depends on package with vulnerability ${getVulnerabilityId(v)}`);
        if (vulnerabilities.module)
            for (const [src, vs] of vulnerabilities.module)
                if (src.packageInfo.isEntry)
                    for (const v of vs)
                        logger.info(`Vulnerability warning: Entry package module ${src} depends on module with vulnerability ${getVulnerabilityId(v)}`);
        if (vulnerabilities.function)
            for (const [src, vs] of vulnerabilities.function)
                if (src.packageInfo.isEntry)
                    for (const v of vs)
                        logger.info(`Vulnerability warning: Entry package function ${src} may reach function with vulnerability ${getVulnerabilityId(v)}`);
        if (vulnerabilities.call)
            for (const [src, vs] of vulnerabilities.call)
                if ((src.loc as Location)?.module?.packageInfo.isEntry)
                    for (const v of vs)
                        logger.info(`Vulnerability warning: Entry package function call site ${locationToStringWithFile(src.loc)} may reach function with vulnerability ${getVulnerabilityId(v)}`);
        if (logger.isDebugEnabled()) {
            if (vulnerabilities.package)
                for (const [src, vs] of vulnerabilities.package)
                    if (!src.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package ${src} depends on package with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.module)
                for (const [src, vs] of vulnerabilities.module)
                    if (!src.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package module ${src} depends on module with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.function)
                for (const [src, vs] of vulnerabilities.function)
                    if (!src.packageInfo.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package function ${src} may reach function with vulnerability ${getVulnerabilityId(v)}`);
            if (vulnerabilities.call)
                for (const [src, vs] of vulnerabilities.call)
                    if (!(src.loc as Location)?.module?.packageInfo.isEntry)
                        for (const v of vs)
                            logger.debug(`Vulnerability warning: Dependency package function call site ${locationToStringWithFile(src.loc)} may reach function with vulnerability ${getVulnerabilityId(v)}`);
        }
        // TODO: also optionally store vr.matches, vr.package, vs.module, vs.function, vs.call?
        // TODO: also report paths using SARIF format?
    }

    /**
     * Checks whether a package matches an OSV entry.
     * Based on https://ossf.github.io/osv-schema/#evaluation.
     */
    private checkPackageMatchesOpenSourceVulnerability(p: PackageInfo, osv: Vulnerability["osv"]): boolean {
        if ("affected" in osv && osv.affected)
            for (const affected of osv.affected)
                if (affected.package && affected.package.ecosystem === "npm" && affected.package.name === p.name) {
                    if (p.version === undefined)
                        return true;
                    if (affected.versions)
                        for (const version of affected.versions)
                            if (version === p.version)
                                return true;
                    if (affected.ranges) {
                        for (const range of affected.ranges) {
                            let beforeLimits = false;
                            if (!range.events.some(event => "limit" in event))
                                beforeLimits = true;
                            else
                                for (const event of range.events)
                                    if (event.limit && (event.limit === "*" || lt(p.version, event.limit))) {
                                        beforeLimits = true;
                                        break;
                                    }
                            if (beforeLimits) {
                                let match = false;
                                for (const event of range.events) { // TODO: assuming already sorted - OK?
                                    if (event.introduced && (event.introduced === "0" || gte(p.version, event.introduced)))
                                        match = true;
                                    else if (event.fixed && gte(p.version, event.fixed))
                                        match = false;
                                    else if (event.last_affected && gt(p.version, event.last_affected))
                                        match = false;
                                }
                                if (match)
                                    return true;
                            }
                        }
                    }
                }
        if ("url" in osv) { // npm audit vulnerability
            if (osv.dependency === p.name) {
                if (p.version === undefined)
                    return true;
                return satisfies(p.version, osv.range);
            }
        }
        return false;
    }

    /**
     * Checks if the location is likely in the module.
     */
    private checkModuleContainsVulnerabilityLocation(moduleInfo: ModuleInfo, loc: Vulnerability["location"]): boolean {
        return Boolean(loc && loc.file === moduleInfo.relativePath);
    }

    /**
     * Checks if the location is likely in the function (or one of its inner functions).
     * It is assumed that the function is in the module.
     */
    private checkFunctionContainsVulnerabilityLocation(fun: NodePath<Function | Class>, loc: Vulnerability["location"]): boolean {
        if (!(loc && loc.file && loc.line && loc.code))
            return false;
        const source = fun.getSource();
        const firstMatch = source.indexOf(loc.code);
        if (firstMatch === -1)
            return false;
        const multipleMatches = source.indexOf(loc.code, firstMatch + 1) !== -1;
        if (!multipleMatches)
            return true;
        return Boolean(fun.node.loc?.start.line && fun.node.loc?.end.line && fun.node.loc?.start.line <= loc.line + 1 && loc.line <= fun.node.loc?.end.line + 1);
    }

    /**
     * Performs pattern matching on the given analysis state.
     */
    patternMatch(fragmentState: FragmentState, typer: TypeScriptTypeInferrer | undefined, diagnostics: AnalysisDiagnostics): PatternMatchVulnerabilities {
        const res = new Map<Node, [Set<Vulnerability>, FunctionInfo | ModuleInfo]>();
        writeStdOutIfActive("Pattern matching...");
        try {
            const matcher = new PatternMatcher(fragmentState, typer);
            for (const [v, ps] of this.patterns)
                for (const p of ps) {
                    const moduleFilter: ModuleFilter = (m) => m instanceof DummyModuleInfo || this.checkPackageMatchesOpenSourceVulnerability(m.packageInfo, v.osv);
                    for (const m of matcher.findDetectionPatternMatches(p, diagnostics, moduleFilter)) { // TODO: special mode for findDetectionPatternMatches to ignore certainty information?
                        logger.info(`Vulnerability pattern match: ${p} at ${locationToStringWithFileAndEnd(m.exp.loc)} (vulnerability: ${getVulnerabilityId(v)})`);
                        mapGetSetPair(res, m.exp, m.encl).add(v);
                    }
                }
        } catch (ex) {
            if (ex instanceof TimeoutException) {
                logger.error("Time limit reached, pattern matching aborted");
                diagnostics.timeout = true;
            } else
                throw ex;
        }
        return res;
    }

    /**
     * Collects all vulnerability results and updates diagnostics.
     */
    collectAllVulnerabilityResults(solver: Solver, typer: TypeScriptTypeInferrer | undefined): VulnerabilityResults {
        const f = solver.fragmentState;
        const vr: VulnerabilityResults = {};
        const t = new Timer();
        vr.matches = this.patternMatch(f, typer, solver.diagnostics);
        const pcks = new Map(this.vulnerabilityPackageMatches);
        const mods = new Map(this.vulnerabilityModuleMatches);
        const funs = new Map(this.vulnerabilityFunctionMatches);
        for (const [vs, fun] of vr.matches.values()) { // add pattern matches to location matches for modules and functions
            const mod = fun instanceof FunctionInfo ? fun.moduleInfo : fun;
            addAll(vs, mapGetSet(funs, fun));
            addAll(vs, mapGetSet(mods, mod));
            addAll(vs, mapGetSet(pcks, mod.packageInfo));
        }
        vr.package = this.findPackagesThatMayDependOnVulnerablePackages(pcks, f);
        vr.module = this.findModulesThatMayDependOnVulnerableModules(mods, f);
        vr.function = this.findFunctionsThatMayReachVulnerableFunctions(funs, f);
        vr.call = this.findCallsThatMayReachVulnerableFunctions(f, vr.function);
        for (const [c, [vs]] of vr.matches) // add pattern matches to location matches for calls
            addAll(vs, mapGetSet(vr.call, c));
        const d = this.diagnostics;
        d.vulnerabilityCollectionTime = t.elapsed(); // TODO: need abort timeout?
        d.distinctVulnerabilities = this.vulnerabilityPackageMatches.values().reduce((p, c) => (addAll(c, p), p), new Set).size;
        d.packagesWithVulnerabilityLocationMatches = this.vulnerabilityPackageMatches.size;
        d.modulesWithVulnerabilityLocationMatches = this.vulnerabilityModuleMatches.size;
        d.functionsWithVulnerabilityLocationMatches = this.vulnerabilityFunctionMatches.size;
        d.nodesWithVulnerabilityPatternMatches = vr.matches.size;
        d.packagesThatMayDependOnVulnerablePackages = vr.package.size;
        d.modulesThatMayDependOnVulnerableModules = vr.module.size;
        d.functionsThatMayReachVulnerableFunctions = vr.function.size;
        d.callsThatMayReachVulnerableFunctions = vr.call.size;
        d.entryPackagesWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityPackageMatches.keys().filter(f => f.isEntry)).length;
        d.entryPackageModulesWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityModuleMatches.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageFunctionsWithVulnerabilityLocationMatches =
            Array.from(this.vulnerabilityFunctionMatches.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageNodesWithVulnerabilityPatternMatches =
            Array.from(vr.matches.entries().filter(([, [, f]]) => f.packageInfo.isEntry)).length;
        d.entryPackagesThatMayDependOnVulnerablePackages =
            Array.from(vr.package.keys().filter(f => f.isEntry)).length;
        d.entryPackageModulesThatMayDependOnVulnerableModules =
            Array.from(vr.module.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageFunctionsThatMayReachVulnerableFunctions =
            Array.from(vr.function.keys().filter(f => f.packageInfo.isEntry)).length;
        d.entryPackageCallsThatMayReachVulnerableFunctions =
            Array.from(vr.call.keys().filter(f => (f.loc as Location)?.module?.packageInfo.isEntry)).length;
        return vr;
    }
}
